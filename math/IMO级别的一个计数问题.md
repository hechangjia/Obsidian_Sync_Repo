---
tags:
  - math
  - 中学数学竞赛
  - 组合学
---

> [!问题]
> $X=\{1,...,2000\}$当中有多少个子集满足子集的全部元素之和能被5整除？

假设$E \in P(X)$是其中一个子集，那么假设$|E| =m$那么只要我们能搞清楚有多少个子集，其元素之和为$m$即可。假设一共有$a_m$个子集使得元素总和为$m$,那么如果没有子集其元素的和能等于某个自然数$m_1$呢？那么此时自然$a_{m_1}=0$,此时对应的子集应该是$\varnothing$.

假设问题中的计数问题的结果为$S$,那么
$$S=\sum_{m\geq 0} a_m\chi_{5|m}$$

那么实际上只要搞清楚$a_m$的生成函数，然后可以把函数$\chi_{5|m}$进行傅里叶展开然后交换求和次序，因此最后的结果就会变成计算五个生成函数的值即可。

这个思路称之为[[利用roots of unity filter求和]].
### 1. $a_m$的生成函数

稍微转换一下这个问题，我们可以把问题归结为这样一个线性方程的解的个数的问题:

> [!等价的问题]
> 求方程：
> $$x_1+2x_2+...+2000x_{2000}=m$$
> 非负整数解的个数$a_m$,其中$x_i \in \{0,1\}$。然后求和,$$S=\sum_{m\geq 0} a_m\chi_{5|m}$$

根据[[线性丢番图方程非负整数解的个数]]以及[[HMMT竞赛的一个组合求和问题]]当中提到的过滤器的想法，我们把方程视为$$y_1+y_2+...+y_{2000}=m$$
其中$y_i \in \{0,i\}$.

按照这个想法，其生成函数也就是每一次从自然数当中选择的时候只选择$\{0,i\}$,实际上就是有这样一个用于判断的函数$$\chi_{i}(k):=\begin{cases}1&k\in\{0,i\}\\ 0&\text{ otherwie}\end{cases}$$
那么每次实际上是在$\chi_i(0)+\chi_i(1)x+...\chi_i(i)x^i+...$当中做出选择，以为$\chi_i$的定义，那么实际上每一次选择余下的部分就是$1+x^i$。所以$a_m$的生成函数就是$F(x)=\prod_{i=0}^{2000}(1+x^i) =\sum_{m\geq 0}a_m x^m$.

### 2. 求和

根据root of unity filter的想法，$$\begin{aligned}S&=\sum_{m\geq 0}a_m\chi_{5|m} \\ &= \sum_{m\geq 0} a_m \frac{1}{5}\sum_{k=0}^{4}\omega^{km} \\ &= \frac{1}{5}\sum_{k=0}^{4}\sum_{m\geq 0}a_m\omega^{km}\\ &= \frac{1}{5}\sum_{k=0}^{4}F(\omega^k)\end{aligned}$$
此处$\omega=e^{\frac{2\pi i}{5} }$.

其中$F(\omega^{0})=F(1)$是特别的，其结果是$2^{2000}$,其余四个值都是一样的。因为$\omega^{1},...,\omega^{4}$都是群$G=\mathbb{Z}(5)$的五阶元，$$\begin{aligned}F(\omega^k)&=\prod_{i=0}^{2000}(1+\omega^{ik})\\&=((1+\omega^0)(1+\omega)(1+\omega^2)(1+\omega^3)(1+\omega^4))^{400} \\ &= 2^{400}\end{aligned}$$
因此最后的结果是$$S = \frac{1}{5}(2^{2000}+4*2^{400})$$
### 3. Wolfram语言的验证

因为2000个元素的集合子集数目太过于庞大，如果一定要用计算机简单枚举运算量太大，因此这里把检验的集合变成$\{1,...,15\}$。根据问题当中的方法，对于$\{1,...,15\}$来说，结果因该是$\frac{2^{15}+4*8}{5}=6560$那么只要计算机也得到这个结果那么说明推导就比较可信。 
```wolfram
(*生成所有子集*)
allSubsets = Subsets[Range[1,15]];
(*验证子集的元素和能否被5整除*)
Count[allSubsets,subset_ /;Mod[Total[subset],5]==0]
```
此处subset_是一种命名模式(named pattern),它能匹配任何表达式.这里subset只是该模式的名称，在这个名称后面加上 “_” 表示在匹配成功以后，我们可以通过这个名字引用匹配到的值。因此此处我们同样可以用别的名称代替那段代码， 比如"x",那么代码就变成了

```wolfram
(*验证子集的元素和能否被5整除*)
Count[allSubsets,x_ /;Mod[Total[x],5]==0]
```

使用/;后面跟一个表达式表示条件模式，只有当后面的条件为真的时候，模式才匹配。比如同样使用Count函数，我们想要数出$\{1,...,15\}$全部的素数，那么语法就可以是

```wolfram
Count[Range[1, 15], x_ /; PrimeQ[x]]
```

