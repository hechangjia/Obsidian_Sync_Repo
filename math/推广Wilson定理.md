---
tags:
  - math
  - 代数基础
---
在[[证明费马小定理]]当中在2.1的位置补充了Wilson定理，即$(\mathbb{Z}/p\mathbb{Z})^{\times}$当中全体元素之积的结果。那么我们会自然的想要知道，这个结果在其他结构上会变成什么样子?

> [!问题]
> 令$(G,\cdot)$是一个有限Abel群，问$$S=\prod_{g \in G}g = ?$$

除了Wilson定理以外我们马上能想到一个特别简单的情况，令此群为$(\mathbb{Z}/n\mathbb{Z},+)$那么此时问题变成了$$S=\sum_{\mathbf{i}\in \mathbb{Z}/n\mathbb{Z}} \mathbf{i} = ?$$这很显然就等于$\frac{n(n+1)}{2}\text{ mod }n$.

1. 如果n是奇数，那么因为$\frac{n+1}{2}$是一个整数，那么自然$S =\mathbf{0}$.此时由群的拉格朗日定理，我们可以知道**此群没有二阶元**，因为2并非n的因子.
2. 如果n是一个偶数，令$\mathbf{a}$为$\frac{n}{2}\text{ mod }n$的剩余类，那么$\mathbf{a}$是一个二阶元。回忆我们在[[证明费马小定理]]当中2.1证明wilson定理时候的操作，如果我们可以确认这就是**此群当中的唯一一个二阶元**，那么问题解决。因为除了单位元$\mathbf{0}$以及二阶元$\mathbf{a}$以外的群当中其余元素都两两配对(互为逆元)。于是最后$S = \mathbf{a}+\mathbf{0}=\mathbf{a}$.

关于n为偶数的情况下，二阶元唯一的证明，我们不妨从循环群的阶开始入手。因为$(\mathbb{Z}/n\mathbb{Z},+)$是一个n阶循环群，并且$n =2k$为一个偶数。群当中任意一个元素$\mathbf{m}$的阶可以表示为$\frac{2k}{(m,2k)}$于是，如果我们假设$\mathbf{m}$是一个二阶元，那么我们就会得到(假设m是剩余内当中非负的最小代表元)$$k=(m,2k)$$这等价于k整除于m并且$(m/k,2)=1$.我们知道$m$只能是等于k.因此$\mathbf{a}$是唯一的二阶元。

结合这个例子以及[[证明费马小定理]]2.1当中Wilson定理也就是$(\mathbb{Z}/p\mathbb{Z})^{\times}$当中的情况，我们隐约感觉，一般情况下的$S$的结果会和群的二阶元有关。
### 1. Wilson定理在任意有限阿贝尔群上的推广
下面是Miller 1903年的结果。

> [!Miller 1903]
> 令$(G,\cdot)$是一个有限Abel群，设$S=\prod_{g \in G}g$那么:
> 1. 如果G当中没有二阶元,那么$S =e$。也就是等于群的单位元。
> 2. 如果G当中有唯一的二阶元a，那么$S = a$.即最后结果就等于这个二阶元。
> 3. 如果G当中有超过一个二阶元，那么最终的结果$S =e$.

因为非二阶元总是可以与自己的逆元两两配对，于是这个命题最终归结为考虑G的子群H，一个由单位元以及$G$的全部**二阶元**构成的群当中全部元素的“乘积”。也就是说$$S = \prod_{h\in H}h$$
前两种情况都比较显然，因为如果G没有二阶元，那么H就是一个只有单位元二点平方的群。如果G只有一个二阶元，那么显然S =e。所以说主要的问题是，如果H这个子群不平凡的情况下(H至少有两个以上二阶元)S的结果。

![[Dihedral group D8的凯莱图2.png]]

> [!注意这里可交换条件的必要性]
> 如果是非交换群，比如Dihedral group $D_8$里头，所有反射都是二阶元，但是这些二阶元(以及单位元)并不构成一个群。因为**在非交换群里面二阶元与二阶元的乘积未必不超过二阶。**
> 
>如图所示，在标记"1"的位置上有一个元素，其置换表示为(1,3)(4,8)(5,7),在标记"2"的位置上有一个元素，其置换表示为(1,4)(2,3)(5,8)(6,7).这两个都是二阶元(图中蓝色大圈上的点都表示$D_8$的反射)，但是二者的乘积是一个8阶元，置换表示为(1,2,3,4,5,6,7,8).原因是因为，前者可以表示为$a$后者可以表示为$b=ar$，其中r是$D_8$的8阶生成元，旋转，那么二者乘积实际上是$a^2r =r$。
>
>这种现象本质上是因为在非交换的代数结构上$(xy)^2 \neq x^2y^2$

对于任意非单位元的$b \in H$,可以考虑一个$H\to H$的对合(involution)映射$$I_b:h\mapsto bh $$
这是一个involution因为$I_b\circ I_b(h)=h$,并且此involution没有不动点，因为如果有不动点，那么就会导致$b=e$这种与假设矛盾的结果。那么我们知道有这样的信息：
* 任意非单位元的$b$构成的$I_b$是双射。
* $h,I_b(h)$这是一对群H当中的元素，不会是同一个元素。

那么此时我们可以考虑在群H当中两两地把$h,bh$进行配对(此群是偶数阶的,因为含有二阶元)。$|H|=2m,m> 1$那么$$S=\prod h\cdot bh = b^m=e $$
#### 1.2 考虑把定理用在$(\mathbb{Z}/n\mathbb{Z})^{\times}$上

首先，此群的阶$|(\mathbb{Z}/n\mathbb{Z})^{\times}| = \varphi(n)$,由于[[欧拉totient函数当n大于2的时候必然是偶数]]，那么我们知道此群必有二阶元，所以接下来的关键就是，二阶元有多少个的问题。

要解决这个问题可以利用中国剩余定理。由中国剩余定理我们知道，如果我们对整数n做分解使得$n = p_1^{a_1}...p_k^{a_k}$那么有$$\mathbb{Z}/n\mathbb{Z} \simeq \mathbb{Z}/p_1^{a_1}\mathbb{Z}\times \cdots \times \mathbb{Z}/p_k^{a_k}\mathbb{Z}$$
这里右边的环当中的元素可以表示为$(x_1,...,x_k)$并且根据每个分量独立地做对应的$\mathbb{Z}/p_i^{a_i}$这个环当中的加法和乘法。

如果我们把环$\mathbb{Z}/n\mathbb{Z}$的单位群(unit group 之所以叫这个名字是因为人们把环当中的所有具有乘法可逆的元素称之为unit)$(\mathbb{Z}/n\mathbb{Z})^{\times}$简写为$U(n)$那么根据中国剩余定理，我们还可以得到$$U(n)\simeq U(p_1^{a_1})\times\cdots \times U(p_k^{a_k})$$
那么回到最初的问题上，想要知道$U(n)$里面有多少个二阶元，我们只需要搞清楚每一个$U(p_i^{a_i})$当中有多少个二阶元。

理由很简单，例如如果我们知道群$G_1$里面有3个二阶元，群$G_2$里面有4个二阶元，那么$G=G_1 \times G_2$里面一共就有$(3+1)\cdot (4+1) -1 = 19$个二阶元。因为直积$G$当中的元素$(x,y)$的阶是由分量在各自群中阶的最小公倍数决定的.$(x,y)$是二阶元，除非x,y当中有一个是单位元，另一个是二阶元，或者两个都是二阶元。第一个群里面的备选项有$\{e_1,a_1,a_2,a_3\}$第二个群里面的备选项有$\{e_1,b_1,b_2,b_3,b_4\}$。这里假设$a_i,b_i$都是二阶元，$e_1,e_2$分别是各自的单位元。那么$(e_1,b_i),(a_i,e_2)$以及$(a_i,b_i)$都是可以接受的情况，唯一不能接受的是$(e_1,e_2)$的情况。因此最后的结果是19个二阶元。

那么$U(p_i^{a_i})$当中有多少个二阶元呢？最多1个，因为它是循环，循环群最多只能有一个二阶元。这句话基于两个结果：

> [!U(p^k)的分类]
> p是素数，那么$U(p^k)=(\mathbb{Z}/p^k\mathbb{Z})^{\times}$的分类为:
> 1. 如果p是奇素数，那么此群为$\varphi(p^k)=p^{k-1}(p-1)$阶循环群。
> 2. 如果$p=2,k\leq 2$,那么此群分别是平凡的循环群，以及2阶循环群。
> 3. 如果$p=2,k >2$那么$$U(2^k)=\mathbb{Z}/2\mathbb{Z} \times \mathbb{Z}/2^{k-2}\mathbb{Z}$$

第二个结果不过是简单的数论

> [!循环群最多有一个二阶元]
> 如果$G$为n阶循环群(n>1).那么，
> 1. 当n为奇数的时候，此群没有二阶元。
> 2. 当n为偶数的时候，此群恰好有一个二阶元。

其本质是因为假设$r^k,k\in \{1,...,n-1\}$是n阶循环群当中的一个元素，$r$是生成元。那么$r^k$的阶为$\frac{n}{(n,k)}$,如果这个量等于2，那么一定有$$\left(2,\frac{2k}{n}\right)=1$$
想要上面的式子成立，实际上只有一种选择，那就是n为偶数，$k = \frac{n}{2}$

更一般的结论，n阶循环群里面如果$d|n$那么此群里面要么没有$d$阶元，要么有$\varphi(d)$个d阶元。在上面的问题当中,$\varphi(2)=1$.

---

在这个基础上还可以确定，如果$U(n)$这个群有且仅有一个二阶元的话，那么一定是$\mathbf{-1}=\mathbf{n-1}$,因为首先一定有$(n-1,n)=1$,也就是说$\mathbf{-1} \in U(n)$，并且因为$(\mathbf{n-1})^2=1$，从环的角度展开它的话，我们可以确认这是一个二阶元。

经过以上的讨论就很容易引入Gauss对此问题的推广了：

> [!Gauss对Wilson定理的推广]
> 对于群$U(n)=(\mathbb{Z}/n\mathbb{Z})^{\times}$令$S_n = \prod_{g\in U(n)} g$,那么：
> 1. 当$n =4,p^a,2p^a$(其中p是奇素数)的时候，$S_n = -\mathbf{1}$
> 2. 其余情况下，$S_n = \mathbf{1}$


Gauss的推广属于是Miller的结果的一个具体的情形，高斯的推广无非就是告诉我们,
1. 当$n =4,p^a,2p^a$(其中p是奇素数)的时候,群$U(n)$有且仅有一个二阶元。
2. 其他情况，群要么没有二阶元，要么有不止一个二阶元。


* 令$n = 2^ap_1^{a_1}...p_k^{a_k}$,排除以上情况，
   * 如果除了2以外没别的素数了,那么$n=2^a$，且$a=1$，此时$U(2)$是一个只有单位元的平凡群，自然$S_n =\mathbf{1}$.
   * 如果除了2以外没别的素数了,那么$n=2^a$，且$a=2$，$\varphi(4)$=2.此时的$U(4)$就是一个二阶循环群,这种循环群也就是一个二阶元，此二阶元恰好是$-\mathbf{1}$。
   * 如果除了2以外没别的素数了,$n=2^a$并且$a >2$那么根据上文提到的$U(p^k)$的分类，$$U(2^k)=\mathbb{Z}/2\mathbb{Z} \times \mathbb{Z}/2^{k-2}\mathbb{Z}$$此群有恰好有三个二阶元.因此最终$S_n =\mathbf{1}$.
   * 如果除了2以外还有一个素数$p$,且$a =1$,也就是说$n=2p^a$那么$$U(2p^a)=U(2)\times U(p^a)$$这种情况下，其实直积的第一个部分是一个平凡的，只有单位元一个元素的循环群，第二个部分有一个二阶元，因此整个结果也只有一个二阶元，此二阶元恰好是$-\mathbf{1}$.
   * 如果除了2以外还有一个素数$p$,且$a >1$，那么$$U(2^ap^b)=U(2^a)\times U(p^b)$$根据上面$U(p^k)$的分类，我们之前左边的群有一个二阶元，右边的群因为是偶数阶循环群所以有且仅有一个二阶元，那么此种情况下$U(2^ap^b)$至少有3个二阶元。因此这种情况下$S_n = \mathbf{1}$.
   * 如果除了2以外还有不止一个素数，也就是说$n = 2^ap_1^{a_1}...p_k^{a_k},k>1$那么此时$$U(n)=U(2^a)\times U(p_1^{a_1}) \times \cdots \times U(p_k^{a_k})$$在这种情况下，在不计算$U(2^a)$的时候，也就是说$(x,y_1,...,y_k)$在$(y_1,...,y_k)$当中就已经保证了至少有3个能使得$(y_1,...,y_k)$为二阶元的情况，那么即便$a =1$，此时$U(n)$也至少有3个二阶元。
* 如果n不是偶数，且有只有一个素因子，也就是$n=p^a,a\geq 1$的时候，我们知道$U(p^a)$是一个$\varphi(p^a)=p^{a-1}(p-1)$的循环群，这个循环群也就是偶数阶的，那么恰好有一个二阶元，此二阶元恰好是$-\mathbf{1}$.
* 如果n不是偶数，且有不止一个素因子，那么和上面的讨论一样，$U(n)$至少有3个二阶元，因此$S_n = \mathbf{1}$.

综上所述，Gauss的这个推广是对的。
### 2. 在不可交换的群上推广?

非交换群上的结果就没有像交换群上那么好的结果了，因为毕竟如果我们要考虑$$S=\prod_{g \in G}g$$的时候我们必须要考虑乘积的顺序，因为交换次序可能会得到完全不同的结果。

#### 2.1 $D_8$上的情况

这里我们通过交换次序来制造不同的$S$的结果。以下是sagemath的代码。

```python
# 以下代码需要在sagemath环境下执行
# 直接在python环境下执行是不行的
import random
from functools import reduce
# 定义八阶的Dihedral Group
G = DihedralGroup(8)
L1 = G.list()

#用来做乘法的匿名函数
f = lambda x, y: x * y

# 初始化一个空集合用于存储不重复的结果
unique_results = set()

for i in range(100):
    result = reduce(f, L1)
    unique_results.add(result)
    #随机交换L1当中的顺序，从而得到不同次序的乘积
    #注意，shuffle函数不会返还任何结果，直接改变L1
    random.shuffle(L1)

# 循环完成后输出所有不重复的结果
for result in unique_results:
    print(result)
```

最后的结果为
```python
(1,5)(2,6)(3,7)(4,8)
(1,3,5,7)(2,4,6,8)
()
(1,7,5,3)(2,8,6,4)
```
我们看到一共有4种不同的结果。

#### 2.1 对称群$S_4$上的情况

我们只需要把上面的sagemath的代码中关于群的定义修改为SymmetricGroup(4)即可，如此一来我们便得到结果

```python
(1,4,3)
(1,4,2)
()
(1,2,3)
(1,4)(2,3)
(1,3)(2,4)
(1,3,4)
(2,3,4)
(1,3,2)
(2,4,3)
(1,2,4)
(1,2)(3,4)
```
共12种不同的结果。